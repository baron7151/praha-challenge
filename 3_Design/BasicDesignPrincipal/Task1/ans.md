参考資料
https://qiita.com/baby-degu/items/d058a62f145235a0f007
https://qiita.com/yuu341/items/1a45048950f3b5b76bdc

SOLID 原則

- SOLID 原則はソフトウェア構築時に従うべきガイドラインで、ソフトウェアの拡張性や保守性を高めるためのものです。下記の５つの原則から構成されています。
  - S (Single Responsibility)　単一責任の原則
    - １つのクラスには単一の責任を持つように設計を行うべきです。１つのクラスに多くの責任があると、バグが発生する可能性が高くなります。なぜなら、その責任の 1 つに変更を加えると、知らないうちに他の責任に影響を与える可能性があるからです。
    - この原則は、変更の結果としてバグが発生しても、他の無関係な動作に影響を与えないように、動作を分離することを目的としています。
  - O (Open-Closed)　オープン・クローズドの原則
    - クラスは、拡張にはオープンで、変更にはクローズドであるべきです。クラスの現在の動作を変更すると、そのクラスを使用するすべてのシステムに影響を与えます。クラスでより多くの関数を実行したい時、理想的な方法は、既存の関数に追加することであり、変更しないことです。
    - この原則は、クラスの既存の動作を変更することなく、クラスの動作を拡張することを目的としています。これは、そのクラスが使用されている場所でバグが発生するのを避けるためです。
  - L (Liskov Substitution)　リスコフの置換原則 - S が T のサブタイプである場合、プログラム内の T 型のオブジェクトを S 型のオブジェクトに置き換えても、そのプログラムの特性は何も変わらないべきです。
    - 子クラスが親クラスと同じ動作を実行できない場合、バグになる可能性があります。クラスから別のクラスを作ると、クラスが親になり、新しいクラスが子になります。子クラスは、親クラスができることをすべてできる必要があります。このプロセスを継承と呼びます。子クラスは、親クラスと同じリクエストを処理し、同じ結果か、同様の結果を提供できなければなりません。
    - この原則は、親クラスやその子クラスがエラーなしで同じ方法で使用できるように、一貫性を保つことを目的としています。
  - I (Interface Segregation)　インターフェイス分離の原則
    - クライアントが使用しないメソッドへの依存を、強制すべきではない。
    - クラスに使用しない動作を実行させようとするのは、無駄が多く、クラスにその動作を実行する機能がない場合、予期しないバグが発生する可能性があります。クラスは、その役割を果たすために必要な動作のみを実行する必要があります。それ以外の動作は完全に削除するか、将来的に他のクラスで使用する可能性がある場合は別の場所に移動すべきです。
    - この原則は、動作のセットをより小さく分割して、クラスが必要なもののみを実行することを目的としています。
  - D (Dependency Inversion)　依存性逆転の原則
    - 上位モジュールは、下位モジュールに依存してはならない。どちらも抽象化に依存すべきだ。抽象化は詳細に依存してはならない。詳細が抽象化に依存すべきだ。
    - 上位モジュール（またはクラス）：ツールを使って動作を実行するクラス
    - 下位モジュール（またはクラス）：動作を実行するために必要なツール
    - 抽象化：2 つのクラスをつなぐインターフェイス
    - 詳細：ツールの動作方法
    - この原則では、クラスは動作を実行するために使用するツールと融合すべきではありません。むしろ、ツールがクラスに接続できるようにするインターフェイスと融合すべきです。また、クラスもインターフェイスも、ツールの動作方法を知るべきではありません。ただし、ツールはインターフェイスの仕様を満たす必要があります。
    - この原則は、インターフェイスを導入することにより、上位レベルのクラスが下位レベルのクラスに依存するのを減らすことを目的としています。

単一原則と単純にファイルを細かなファイルに分解することの違い

- 単一原則はクラスは単一の責任を担うように設計するべきという設計原則である。もし、ファイル B がファイル A にあるメソッドに単一原則から外れて依存した場合は、A の仕様変更が B に影響を及ぼしてしまうため、それは単一原則に準拠しているとは言えない。単一原則は責任に関心を持って分離することであるので、細かにファイル分割したとしても、単一原則に準拠しているとは言えない。

- Open-Closed-Principle の実例

```

interface Printer {
  print(): void;
}

class ConsolePrinter implements Printer {
  print(): void {
    console.log('Printing to console');
  }
}

class FilePrinter implements Printer {
  print(): void {
    console.log('Printing to file');
  }
}

function printAll(printers: Printer[]): void {
  for (const printer of printers) {
    printer.print();
  }
}

const consolePrinter = new ConsolePrinter();
const filePrinter = new FilePrinter();

printAll([consolePrinter, filePrinter]); // Printing to console, Printing to file

```

上記の例では、Printer インターフェースを使用して、ConsolePrinter クラスと FilePrinter クラスが print() メソッドを実装することを保証しています。printAll() 関数は、Printer インターフェースを実装する異なる種類のプリンターを受け取り、それら print() メソッドで出力します。

新しいプリンターを追加して出力する場合には、Printer インターフェースを実装するだけでよく、printAll() 関数を変更する必要はありません。このように、コードが拡張可能であり、クローズドであるため、OCP の原則に準拠しています。

リスコフの置換原則に違反のデメリット

- 拡張性の低下
  - サブクラスが拡張されるたびに、親クラスで定義されたメソッドを使用するコードの修正が必要になる場合がある。コードの拡張性が低下し、保守性が悪くなる可能性があります。
- バグが発生しやすくなる
  - サブクラスで実装されたメソッドが親クラスのメソッドと異なる動作をする場合、予期しない値が返されたり、不正な値が使用されたりする可能性がある。
- コードが難解になる
  - 親クラスで定義された前提条件が破壊されたサブクラスのメソッドが呼び出された場合、コードの振る舞いが予想通りでないため、そのコードを理解するのが難しくなる可能性があります。

インターフェースを用いる設計上のメリット

- 異なるクラスで同じメソッドを実装することができるため、コードの再利用性が高まる。
- カプセル化を強制するため、外部から意図しないアクセスを防ぎ、保守性や信頼性が向上する。

依存性の逆転を用いるケース

- フレームワークやライブラリを利用する場合、フレームワークとライブラリの抽象的なインターフェースに依存することで、ライブラリやフレームワークの変更を行いやすくなる。
- DI を利用してテスト容易性を向上させたいときに利用すると、上位のモジュールが下位のモジュールに依存しなくなり、下位のモジュールの仕様変更の影響を受けにくくなるため、保守性が向上する。

デメトルの法則とは？メリット含めて

- デメトルの法則は、オブジェクト指向プログラミングでオブジェクト間の結合度を下げるための法則で、メソッド内で呼び出されるメソッドについて制限を行うものである。オブジェクトのメンバのプロパティへの直接アクセスやオブジェクトのメンバのメンバをプロパティやメソッドへのアクセスは最小限にするべきである。
- デメトルの法則のメリットは、オブジェクト間の依存関係が減少するため、拡張が容易になり、テスト容易性やコードの可読性が向上する。

記載されているコードでは保守性に対して効果が無いことの説明

- 単に getter や setter を用意しただけでは、オブジェクト間の結合度は下がらない。たとえば、Purchase クラスの上位にクラスがあって、xxx.purchase.userId と呼び出して、user_id を取得した場合は、呼び出し元のクラスは、xxx クラスと purchase クラスに依存してしまっているため、保守性が高いとは言えない。
